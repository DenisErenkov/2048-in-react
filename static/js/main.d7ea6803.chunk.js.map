{"version":3,"sources":["context/TileContainer.tsx","models/Board.ts","hooks/useIds.ts","hooks/useGame.ts","components/Grid/Grid.tsx","hooks/usePrevProps.ts","components/Tile/Tile.tsx","hooks/useTileContainer.ts","components/Board/Board.tsx","components/Button/Button.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["TileContainerContext","React","createContext","length","TileContainer","children","Provider","value","animationDuration","seqId","initialState","tiles","byIds","hasChanged","inMotion","reducer","state","action","type","tile","id","source","destination","restTiles","position","filter","useGame","isInitialRender","useRef","nextId","useReducer","dispatch","createTile","useCallback","throttledMergeTile","setTimeout","mergeTile","updateTile","didTileMove","hasXChanged","hasYChanged","retrieveTileMap","tileMap","Array","size","fill","forEach","index","positionToIndex","findEmptyTiles","reduce","result","tileId","indexToPosition","generateRandomTile","emptyTiles","Math","floor","random","useEffect","current","map","nonEmptyTiles","previousTile","mergeCount","i","currentTile","undefined","mergeWith","reverse","Grid","className","cells","push","renderGrid","usePrevProps","ref","Tile","zIndex","withinBoardBoundaries","invariant","useState","scale","setScale","useContext","boardLength","prevValue","shallAnimate","positionToPixels","style","top","left","transform","Board","tileManagerRef","setLength","moveLeft","moveRight","moveUp","moveDown","throttledHandleKeyDown","useThrottledCallback","e","code","leading","trailing","offsetWidth","window","addEventListener","removeEventListener","tileList","restProps","renderTiles","Button","onClick","App","Date","date","setDate","toISOString","href","target","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"8SAEaA,EAAuBC,IAAMC,cAAc,CACtDC,OAAQ,IAQGC,EAAgB,SAAC,GAAqC,IAAnCC,EAAkC,EAAlCA,SAAkC,IAAxBF,cAAwB,MAAf,EAAe,EAChE,OACE,cAACH,EAAqBM,SAAtB,CAA+BC,MAAO,CAAEJ,UAAxC,SACGE,K,sBCAMG,EAAoB,ICd7BC,EAAQ,ECoBNC,EAAsB,CAC1BC,MAAO,GACPC,MAAO,GACPC,YAAY,EACZC,UAAU,GAUNC,EAAU,SAACC,EAAcC,GAC7B,OAAQA,EAAOC,MACb,IAAK,cACH,OAAO,2BACFF,GADL,IAEEL,MAAM,2BACDK,EAAML,OADN,kBAEFM,EAAOE,KAAKC,GAAKH,EAAOE,OAE3BP,MAAM,GAAD,mBAAMI,EAAMJ,OAAZ,CAAmBK,EAAOE,KAAKC,KACpCP,YAAY,IAEhB,IAAK,cACH,OAAO,2BACFG,GADL,IAEEL,MAAM,2BACDK,EAAML,OADN,kBAEFM,EAAOE,KAAKC,GAAKH,EAAOE,OAE3BN,YAAY,IAEhB,IAAK,aACH,MAIIG,EAAML,MAJV,EACGM,EAAOI,OAAOD,GADjB,EAEGH,EAAOK,YAAYF,GACjBG,GAHL,yCAKA,OAAO,2BACFP,GADL,IAEEL,MAAM,2BACDY,GADA,kBAEFN,EAAOK,YAAYF,GAAK,CACvBA,GAAIH,EAAOK,YAAYF,GACvBb,MAAOU,EAAOI,OAAOd,MAAQU,EAAOK,YAAYf,MAChDiB,SAAUP,EAAOK,YAAYE,YAGjCZ,MAAOI,EAAMJ,MAAMa,QAAO,SAACL,GAAD,OAAQA,IAAOH,EAAOI,OAAOD,MACvDP,YAAY,IAEhB,IAAK,aACH,OAAO,2BACFG,GADL,IAEEF,UAAU,IAEd,IAAK,WACH,OAAO,2BACFE,GADL,IAEEF,UAAU,IAEd,QACE,OAAOE,IAIAU,EAAU,WACrB,IAAMC,EAAkBC,kBAAO,GAC/B,ED/EO,CAJQ,WACb,OAAOnB,MCkFFoB,EAAP,oBAEA,EAA0BC,qBAAWf,EAASL,GAA9C,mBAAOM,EAAP,KAAce,EAAd,KACQpB,EAAuCK,EAAvCL,MAAOC,EAAgCI,EAAhCJ,MAAOC,EAAyBG,EAAzBH,WAAYC,EAAaE,EAAbF,SAE5BkB,EAAaC,uBACjB,YAA6C,IAA1CT,EAAyC,EAAzCA,SAAUjB,EAA+B,EAA/BA,MACLY,EAAO,CACXC,GAAIS,IACJL,WACAjB,SAEFwB,EAAS,CAAEb,KAAM,cAAeC,WAElC,CAACU,IAQGK,EAAqB,SAACb,EAAkBC,GAC5Ca,YAAW,kBANK,SAACd,EAAkBC,GACnCS,EAAS,CAAEb,KAAM,aAAcG,SAAQC,gBAKtBc,CAAUf,EAAQC,KAAcd,IAG7C6B,EAAa,SAAClB,GAClBY,EAAS,CAAEb,KAAM,cAAeC,UAG5BmB,EAAc,SAACjB,EAAkBC,GACrC,IAAMiB,EAAclB,EAAOG,SAAS,KAAOF,EAAYE,SAAS,GAC1DgB,EAAcnB,EAAOG,SAAS,KAAOF,EAAYE,SAAS,GAEhE,OAAOe,GAAeC,GAGlBC,EAAkBR,uBAAY,WAClC,IAAMS,EAAU,IAAIC,MAAMC,IAAaC,KAAK,GAQ5C,OANAjC,EAAMkC,SAAQ,SAAC1B,GACb,IAAQI,EAAab,EAAMS,GAAnBI,SACFuB,EAAQC,EAAgBxB,GAC9BkB,EAAQK,GAAS3B,KAGZsB,IACN,CAAC9B,EAAOD,IAELsC,EAAiBhB,uBAAY,WAWjC,OAVgBQ,IAEWS,QAAO,SAACC,EAAQC,EAAQL,GACjD,OAAe,IAAXK,EACI,GAAN,mBAAWD,GAAX,CAAmBE,EAAgBN,KAG9BI,IACN,MAGF,CAACV,IAEEa,EAAqBrB,uBAAY,WACrC,IAAMsB,EAAaN,IAEnB,GAAIM,EAAWpD,OAAS,EAAG,CACzB,IACMqB,EAAW+B,EADHC,KAAKC,MAAMD,KAAKE,SAAWH,EAAWpD,SAGpD6B,EAAW,CAAER,WAAUjB,MAAO,OAE/B,CAAC0C,EAAgBjB,IAEdgB,EAAkB,SAACxB,GACvB,OFhKgB,EEgKTA,EAAS,GAAYA,EAAS,IAGjC6B,EAAkB,SAACN,GAGvB,MAAO,CAFGA,EFpKM,EEqKNS,KAAKC,MAAMV,EFrKL,KE6YlB,OAdAY,qBAAU,WACR,GAAIhC,EAAgBiC,QAIlB,OAHA5B,EAAW,CAAER,SAAU,CAAC,EAAG,GAAIjB,MAAO,IACtCyB,EAAW,CAAER,SAAU,CAAC,EAAG,GAAIjB,MAAO,SACtCoB,EAAgBiC,SAAU,IAIvB9C,GAAYD,GACfyC,MAED,CAACzC,EAAYC,EAAUkB,EAAYsB,IAG/B,CADU1C,EAAMiD,KAAI,SAACT,GAAD,OAAYzC,EAAMyC,MAnO5B,WACf,IAAMV,EAAUD,IAEhBV,EAAS,CAAEb,KAAM,eAEjB,IALqB,eAKZ6B,GAEP,IAOMe,EAPe,CACnBpB,EFjLY,EEiLJK,EAAe,GACvBL,EFlLY,EEkLJK,EAAe,GACvBL,EFnLY,EEmLJK,EAAe,GACvBL,EFpLY,EEoLJK,EAAe,IAGUtB,QAAO,SAACL,GAAD,OAAe,IAAPA,KAC9C2C,OAAkC,EAClCC,EAAa,EAEjBF,EAAchB,SAAQ,SAACM,EAAQa,GAC7B,IAAMC,EAAcvD,EAAMyC,GAE1B,QACmBe,IAAjBJ,GACAA,EAAaxD,QAAU2D,EAAY3D,MACnC,CACA,IAAMY,EAAI,2BACL+C,GADK,IAER1C,SAAUuC,EAAavC,SACvB4C,UAAWL,EAAa3C,KAM1B,OAHAc,EAAmBf,EAAM4C,GACzBA,OAAeI,EACfH,GAAc,EACP3B,EAAWlB,GAGpB,IAAMA,EAAI,2BACL+C,GADK,IAER1C,SAAU6B,EFhNA,EEgNgBN,EAAekB,EAAID,KAK/C,GAFAD,EAAe5C,EAEXmB,EAAY4B,EAAa/C,GAC3B,OAAOkB,EAAWlB,OAxCf4B,EAAQ,EAAGA,EF9KJ,EE8KkBA,GAAS,EAAI,EAAtCA,GA8CTZ,YAAW,kBAAMJ,EAAS,CAAEb,KAAM,eAAeV,IAGjC,WAChB,IAAMkC,EAAUD,IAChBV,EAAS,CAAEb,KAAM,eAEjB,IAJsB,eAIb6B,GAEP,IAOMe,EAPe,CACnBpB,EFtOY,EEsOJK,EAAe,GACvBL,EFvOY,EEuOJK,EAAe,GACvBL,EFxOY,EEwOJK,EAAe,GACvBL,EFzOY,EEyOJK,EAAe,IAGUtB,QAAO,SAACL,GAAD,OAAe,IAAPA,KAAUiD,UAExDN,OAAkC,EAClCC,EAAa,EAEjBF,EAAchB,SAAQ,SAACM,EAAQa,GAC7B,IAAMC,EAAcvD,EAAMyC,GAE1B,QACmBe,IAAjBJ,GACAA,EAAaxD,QAAU2D,EAAY3D,MACnC,CACA,IAAMY,EAAI,2BACL+C,GADK,IAER1C,SAAUuC,EAAavC,SACvB4C,UAAWL,EAAa3C,KAM1B,OAHAc,EAAmBf,EAAM4C,GACzBA,OAAeI,EACfH,GAAc,EACP3B,EAAWlB,GAGpB,IAAMA,EAAI,2BACL+C,GADK,IAER1C,SAAU6B,EFtQA,EEsQgBN,EAzBbH,EAyBuCoB,EAAaC,KAKnE,GAFAF,EAAe5C,EAEXmB,EAAY4B,EAAa/C,GAC3B,OAAOkB,EAAWlB,OAzCf4B,EAAQ,EAAGA,EFnOJ,EEmOkBA,GAAS,EAAI,EAAtCA,GA+CTZ,YAAW,kBAAMJ,EAAS,CAAEb,KAAM,eAAeV,IAGpC,WACb,IAAMkC,EAAUD,IAChBV,EAAS,CAAEb,KAAM,eAEjB,IAJmB,eAIV6B,GAEP,IAOMe,EAPkB,CACtBpB,EAAQK,EAAQH,GAChBF,EAAQK,EAAQH,GAChBF,EAAQK,EAAQH,GAChBF,EAAQK,EAAQH,KAGoBnB,QAAO,SAACL,GAAD,OAAe,IAAPA,KACjD2C,OAAkC,EAClCC,EAAa,EAEjBF,EAAchB,SAAQ,SAACM,EAAQa,GAC7B,IAAMC,EAAcvD,EAAMyC,GAE1B,QACmBe,IAAjBJ,GACAA,EAAaxD,QAAU2D,EAAY3D,MACnC,CACA,IAAMY,EAAI,2BACL+C,GADK,IAER1C,SAAUuC,EAAavC,SACvB4C,UAAWL,EAAa3C,KAM1B,OAHAc,EAAmBf,EAAM4C,GACzBA,OAAeI,EACfH,GAAc,EACP3B,EAAWlB,GAGpB,IAAMA,EAAI,2BACL+C,GADK,IAER1C,SAAU6B,EAAgBN,EF3ThB,GE2TgCkB,EAAID,MAIhD,GAFAD,EAAe5C,EAEXmB,EAAY4B,EAAa/C,GAC3B,OAAOkB,EAAWlB,OAvCf4B,EAAQ,EAAGA,EFzRJ,EEyRkBA,GAAS,EAAI,EAAtCA,GA6CTZ,YAAW,kBAAMJ,EAAS,CAAEb,KAAM,eAAeV,IAGlC,WACf,IAAMkC,EAAUD,IAChBV,EAAS,CAAEb,KAAM,eAEjB,IAJqB,eAIZ6B,GAEP,IAOMe,EAPkB,CACtBpB,EAAQK,EAAQH,GAChBF,EAAQK,EAAQH,GAChBF,EAAQK,EAAQH,GAChBF,EAAQK,EAAQH,KAGoBnB,QAAO,SAACL,GAAD,OAAe,IAAPA,KAAUiD,UAG3DN,OAAkC,EAClCC,EAAa,EAEjBF,EAAchB,SAAQ,SAACM,EAAQa,GAC7B,IAAMC,EAAcvD,EAAMyC,GAE1B,QACmBe,IAAjBJ,GACAA,EAAaxD,QAAU2D,EAAY3D,MACnC,CACA,IAAMY,EAAI,2BACL+C,GADK,IAER1C,SAAUuC,EAAavC,SACvB4C,UAAWL,EAAa3C,KAM1B,OAHAc,EAAmBf,EAAM4C,GACzBA,OAAeI,EACfH,GAAc,EACP3B,EAAWlB,GAGpB,IAAMA,EAAI,2BACL+C,GADK,IAER1C,SAAU6B,EAAgBN,EFjXhB,GEuVGH,EA0BwCqB,EAAID,MAK3D,GAFAD,EAAe5C,EAEXmB,EAAY4B,EAAa/C,GAC3B,OAAOkB,EAAWlB,OA1Cf4B,EAAQ,EAAGA,EF7UJ,EE6UkBA,GAAS,EAAI,EAAtCA,GA+CTZ,YAAW,kBAAMJ,EAAS,CAAEb,KAAM,eAAeV,MC5XxC8D,G,MAAO,WAYlB,OAAO,qBAAKC,UAAU,OAAf,SAXY,WAIjB,IAHA,IACMC,EAAQ,GAELzB,EAAQ,EAAGA,EAHLH,GAGqBG,GAAS,EAC3CyB,EAAMC,KAAK,qBAAsBF,UAAS,aAA/B,UAAaxB,KAG1B,OAAOyB,EAGqBE,O,QCTnBC,EAAe,SAAUpE,GACpC,IAAMqE,EAAMhD,mBAMZ,OAJA+B,qBAAU,WACRiB,EAAIhB,QAAUrD,KAGTqE,EAAIhB,SCHAiB,G,MAAO,SAAC,GAAwC,IAAtCtE,EAAqC,EAArCA,MAAOiB,EAA8B,EAA9BA,SAAUsD,EAAoB,EAApBA,OAChCC,EAAwBvD,EAAS,GLRrB,GKQkCA,EAAS,GLR3C,EKSlBwD,YAAUD,EAAuB,qBAEjC,MAA0BE,mBAAS,GAAnC,mBAAOC,EAAP,KAAcC,EAAd,KAEA,ECRO,CAFYC,qBAAWpF,GAAtBG,QDUDkF,EAAP,oBACMC,EAAYX,EAAqBpE,GAKjCgF,OAFuBpB,IAFVQ,EAA+BnD,IAG/B8D,IAAc/E,EAGjCoD,qBAAU,WACJ4B,IACFJ,EAAS,KACThD,YAAW,kBAAMgD,EAAS,KAAI,QAE/B,CAACI,EAAcL,IAElB,IAAMM,EAAmB,SAAChE,GACxB,OAAQA,EL7BQ,EK6BY6D,GAGxBI,EAAQ,CACZC,IAAKF,EAAiBhE,EAAS,IAC/BmE,KAAMH,EAAiBhE,EAAS,IAChCoE,UAAU,SAAD,OAAWV,EAAX,KACTJ,UAGF,OACE,qBAAKP,UAAS,oBAAehE,GAASkF,MAAOA,EAA7C,SACGlF,M,iBEtCMsF,EAAQ,WACnB,IAAMC,EAAiBlE,iBAAuB,MAC9C,EAA4BqD,mBAAS,GAArC,mBAAO9E,EAAP,KAAe4F,EAAf,KACA,EAAuDrE,IAAvD,mBAAOf,EAAP,KAAcqF,EAAd,KAAwBC,EAAxB,KAAmCC,EAAnC,KAA2CC,EAA3C,KAmBMC,EAAyBC,aAjBT,SAACC,GACrB,OAAQA,EAAEC,MACR,IAAK,YACHP,IACA,MACF,IAAK,aACHC,IACA,MACF,IAAK,UACHC,IACA,MACF,IAAK,YACHC,OAOJ3F,EACA,CAAEgG,SAAS,EAAMC,UAAU,IAG7B9C,qBAAU,WACuB,OAA3BmC,EAAelC,SACjBmC,EAAWD,EAAelC,QAA2B8C,eAEtD,IAEH/C,qBAAU,WAGR,OAFAgD,OAAOC,iBAAiB,UAAWR,GAE5B,WACLO,OAAOE,oBAAoB,UAAWT,MAEvC,CAACA,IAcJ,OACE,sBAAK7B,UAAU,QAAf,UACE,cAAC,EAAD,CAAepE,OAAQA,EAAvB,SACE,qBAAKoE,UAAU,iBAAiBK,IAAKkB,EAArC,SAfc,WAClB,GAAe,IAAX3F,EACF,OAAO,KAGT,IAAM2G,EAAWnG,EAAMkD,KAAI,gBAAGzC,EAAH,EAAGA,GAAO2F,EAAV,wBACzB,cAAC,EAAD,2BAA6BA,GAA7B,IAAwCjC,OAAQ1D,IAAhD,eAAmBA,OAGrB,OAAO,mCAAG0F,IAOHE,OAGL,cAAC,EAAD,QC9DOC,G,MAAS,SAAC,GAAkC,IAAhC5G,EAA+B,EAA/BA,SAAU6G,EAAqB,EAArBA,QACjC,OACE,wBAAQ3C,UAAU,SAAS2C,QAASA,EAApC,SACG7G,MCLM8G,G,MAAM,WACjB,MAAwBlC,mBAAe,IAAImC,MAA3C,mBAAOC,EAAP,KAAaC,EAAb,KAMA,OACE,sBAAK/C,UAAU,MAAf,UACE,sBAAKA,UAAU,SAAf,UACE,8BACE,6CAEF,8BACE,cAAC,EAAD,CAAQ2C,QAXM,WACpBI,EAAQ,IAAIF,OAUN,0BAGJ,cAAC,EAAD,GAAYC,EAAKE,eACjB,gCACE,8BACE,8DADF,mDAIA,+BACE,6BACE,mBACEC,KAAK,2DACLC,OAAO,SAFT,kCAOF,6BACE,mBACED,KAAK,kDACLC,OAAO,SAFT,oCAOF,6BACE,mBACED,KAAK,2DACLC,OAAO,SAFT,oDAQJ,kEACmC,sCADnC,QACoD,2CADpD,6JAOF,sBAAKlD,UAAU,SAAf,sCACkB,IAChB,mBACEiD,KAAK,2DACLC,OAAO,SAFT,iCClDOC,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCJdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.d7ea6803.chunk.js","sourcesContent":["import React from \"react\";\n\nexport const TileContainerContext = React.createContext({\n  length: 0,\n});\n\ntype Props = {\n  length: number;\n  children: any;\n};\n\nexport const TileContainer = ({ children, length = 0 }: Props) => {\n  return (\n    <TileContainerContext.Provider value={{ length }}>\n      {children}\n    </TileContainerContext.Provider>\n  );\n};\n","/**\n * The number of rows and columns.\n * IMPORTANT! Check styles before changing this value!\n *\n * @constant {number}\n */\nexport const size = 4;\n\n/**\n * The duration of every animation in ms.\n * IMPORTANT! Check styles before modyfing this value!\n *\n * @constant {number} ms\n */\nexport const animationDuration = 250;\n","let seqId = 1;\n\n/**\n * Returns next sequential number.\n *\n * @returns {number}\n */\nexport const useIds = () => {\n  const nextId = () => {\n    return seqId++;\n  };\n\n  return [nextId];\n};\n","import { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport { animationDuration, size } from \"../models/Board\";\nimport { useIds } from \"./useIds\";\n\nexport type TileMeta = {\n  id: number;\n  position: [number, number];\n  value: number;\n  mergeWith?: number;\n};\n\ntype State = {\n  tiles: {\n    [id: number]: TileMeta;\n  };\n  inMotion: boolean;\n  hasChanged: boolean;\n  byIds: number[];\n};\n\nconst initialState: State = {\n  tiles: {},\n  byIds: [],\n  hasChanged: false,\n  inMotion: false,\n};\n\ntype Action =\n  | { type: \"CREATE_TILE\"; tile: TileMeta }\n  | { type: \"UPDATE_TILE\"; tile: TileMeta }\n  | { type: \"MERGE_TILE\"; source: TileMeta; destination: TileMeta }\n  | { type: \"START_MOVE\" }\n  | { type: \"END_MOVE\" };\n\nconst reducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case \"CREATE_TILE\":\n      return {\n        ...state,\n        tiles: {\n          ...state.tiles,\n          [action.tile.id]: action.tile,\n        },\n        byIds: [...state.byIds, action.tile.id],\n        hasChanged: false,\n      };\n    case \"UPDATE_TILE\":\n      return {\n        ...state,\n        tiles: {\n          ...state.tiles,\n          [action.tile.id]: action.tile,\n        },\n        hasChanged: true,\n      };\n    case \"MERGE_TILE\":\n      const {\n        [action.source.id]: source,\n        [action.destination.id]: destination,\n        ...restTiles\n      } = state.tiles;\n      return {\n        ...state,\n        tiles: {\n          ...restTiles,\n          [action.destination.id]: {\n            id: action.destination.id,\n            value: action.source.value + action.destination.value,\n            position: action.destination.position,\n          },\n        },\n        byIds: state.byIds.filter((id) => id !== action.source.id),\n        hasChanged: true,\n      };\n    case \"START_MOVE\":\n      return {\n        ...state,\n        inMotion: true,\n      };\n    case \"END_MOVE\":\n      return {\n        ...state,\n        inMotion: false,\n      };\n    default:\n      return state;\n  }\n};\n\nexport const useGame = () => {\n  const isInitialRender = useRef(true);\n  const [nextId] = useIds();\n  // state\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const { tiles, byIds, hasChanged, inMotion } = state;\n\n  const createTile = useCallback(\n    ({ position, value }: Partial<TileMeta>) => {\n      const tile = {\n        id: nextId(),\n        position,\n        value,\n      } as TileMeta;\n      dispatch({ type: \"CREATE_TILE\", tile });\n    },\n    [nextId]\n  );\n\n  const mergeTile = (source: TileMeta, destination: TileMeta) => {\n    dispatch({ type: \"MERGE_TILE\", source, destination });\n  };\n\n  // A must-have to keep the sliding animation if the action merges tiles together.\n  const throttledMergeTile = (source: TileMeta, destination: TileMeta) => {\n    setTimeout(() => mergeTile(source, destination), animationDuration);\n  };\n\n  const updateTile = (tile: TileMeta) => {\n    dispatch({ type: \"UPDATE_TILE\", tile });\n  };\n\n  const didTileMove = (source: TileMeta, destination: TileMeta) => {\n    const hasXChanged = source.position[0] !== destination.position[0];\n    const hasYChanged = source.position[1] !== destination.position[1];\n\n    return hasXChanged || hasYChanged;\n  };\n\n  const retrieveTileMap = useCallback(() => {\n    const tileMap = new Array(size * size).fill(0) as number[];\n\n    byIds.forEach((id) => {\n      const { position } = tiles[id];\n      const index = positionToIndex(position);\n      tileMap[index] = id;\n    });\n\n    return tileMap;\n  }, [byIds, tiles]);\n\n  const findEmptyTiles = useCallback(() => {\n    const tileMap = retrieveTileMap();\n\n    const emptyTiles = tileMap.reduce((result, tileId, index) => {\n      if (tileId === 0) {\n        return [...result, indexToPosition(index) as [number, number]];\n      }\n\n      return result;\n    }, [] as [number, number][]);\n\n    return emptyTiles;\n  }, [retrieveTileMap]);\n\n  const generateRandomTile = useCallback(() => {\n    const emptyTiles = findEmptyTiles();\n\n    if (emptyTiles.length > 0) {\n      const index = Math.floor(Math.random() * emptyTiles.length);\n      const position = emptyTiles[index];\n\n      createTile({ position, value: 2 });\n    }\n  }, [findEmptyTiles, createTile]);\n\n  const positionToIndex = (position: [number, number]) => {\n    return position[1] * size + position[0];\n  };\n\n  const indexToPosition = (index: number) => {\n    const x = index % size;\n    const y = Math.floor(index / size);\n    return [x, y];\n  };\n\n  const moveLeft = () => {\n    const tileMap = retrieveTileMap();\n\n    dispatch({ type: \"START_MOVE\" });\n\n    for (let index = 0; index < size; index += 1) {\n      // TODO make more bulletproof - size might change\n      const tileIdsInRow = [\n        tileMap[index * size + 0],\n        tileMap[index * size + 1],\n        tileMap[index * size + 2],\n        tileMap[index * size + 3],\n      ];\n\n      const nonEmptyTiles = tileIdsInRow.filter((id) => id !== 0);\n      let previousTile: TileMeta | undefined;\n      let mergeCount = 0;\n\n      nonEmptyTiles.forEach((tileId, i) => {\n        const currentTile = tiles[tileId];\n\n        if (\n          previousTile !== undefined &&\n          previousTile.value === currentTile.value\n        ) {\n          const tile = {\n            ...currentTile,\n            position: previousTile.position,\n            mergeWith: previousTile.id,\n          } as TileMeta;\n\n          throttledMergeTile(tile, previousTile);\n          previousTile = undefined;\n          mergeCount += 1;\n          return updateTile(tile);\n        }\n\n        const tile = {\n          ...currentTile,\n          position: indexToPosition(index * size + i - mergeCount),\n        } as TileMeta;\n\n        previousTile = tile;\n\n        if (didTileMove(currentTile, tile)) {\n          return updateTile(tile);\n        }\n      });\n    }\n\n    // wait until the end of all animations.\n    setTimeout(() => dispatch({ type: \"END_MOVE\" }), animationDuration);\n  };\n\n  const moveRight = () => {\n    const tileMap = retrieveTileMap();\n    dispatch({ type: \"START_MOVE\" });\n\n    for (let index = 0; index < size; index += 1) {\n      // TODO make more bulletproof - size might change\n      const tileIdsInRow = [\n        tileMap[index * size + 0],\n        tileMap[index * size + 1],\n        tileMap[index * size + 2],\n        tileMap[index * size + 3],\n      ];\n\n      const nonEmptyTiles = tileIdsInRow.filter((id) => id !== 0).reverse();\n      const maxIndex = size - 1;\n      let previousTile: TileMeta | undefined;\n      let mergeCount = 0;\n\n      nonEmptyTiles.forEach((tileId, i) => {\n        const currentTile = tiles[tileId];\n\n        if (\n          previousTile !== undefined &&\n          previousTile.value === currentTile.value\n        ) {\n          const tile = {\n            ...currentTile,\n            position: previousTile.position,\n            mergeWith: previousTile.id,\n          } as TileMeta;\n\n          throttledMergeTile(tile, previousTile);\n          previousTile = undefined;\n          mergeCount += 1;\n          return updateTile(tile);\n        }\n\n        const tile = {\n          ...currentTile,\n          position: indexToPosition(index * size + maxIndex + mergeCount - i),\n        } as TileMeta;\n\n        previousTile = tile;\n\n        if (didTileMove(currentTile, tile)) {\n          return updateTile(tile);\n        }\n      });\n    }\n\n    // wait until the end of all animations.\n    setTimeout(() => dispatch({ type: \"END_MOVE\" }), animationDuration);\n  };\n\n  const moveUp = () => {\n    const tileMap = retrieveTileMap();\n    dispatch({ type: \"START_MOVE\" });\n\n    for (let index = 0; index < size; index += 1) {\n      // TODO make more bulletproof - size might change\n      const tileIdsInColumn = [\n        tileMap[index + size * 0],\n        tileMap[index + size * 1],\n        tileMap[index + size * 2],\n        tileMap[index + size * 3],\n      ];\n\n      const nonEmptyTiles = tileIdsInColumn.filter((id) => id !== 0);\n      let previousTile: TileMeta | undefined;\n      let mergeCount = 0;\n\n      nonEmptyTiles.forEach((tileId, i) => {\n        const currentTile = tiles[tileId];\n\n        if (\n          previousTile !== undefined &&\n          previousTile.value === currentTile.value\n        ) {\n          const tile = {\n            ...currentTile,\n            position: previousTile.position,\n            mergeWith: previousTile.id,\n          } as TileMeta;\n\n          throttledMergeTile(tile, previousTile);\n          previousTile = undefined;\n          mergeCount += 1;\n          return updateTile(tile);\n        }\n\n        const tile = {\n          ...currentTile,\n          position: indexToPosition(index + size * (i - mergeCount)),\n        } as TileMeta;\n        previousTile = tile;\n\n        if (didTileMove(currentTile, tile)) {\n          return updateTile(tile);\n        }\n      });\n    }\n\n    // wait until the end of all animations.\n    setTimeout(() => dispatch({ type: \"END_MOVE\" }), animationDuration);\n  };\n\n  const moveDown = () => {\n    const tileMap = retrieveTileMap();\n    dispatch({ type: \"START_MOVE\" });\n\n    for (let index = 0; index < size; index += 1) {\n      // TODO make more bulletproof - size might change\n      const tileIdsInColumn = [\n        tileMap[index + size * 0],\n        tileMap[index + size * 1],\n        tileMap[index + size * 2],\n        tileMap[index + size * 3],\n      ];\n\n      const nonEmptyTiles = tileIdsInColumn.filter((id) => id !== 0).reverse();\n      const maxIndex = size - 1;\n\n      let previousTile: TileMeta | undefined;\n      let mergeCount = 0;\n\n      nonEmptyTiles.forEach((tileId, i) => {\n        const currentTile = tiles[tileId];\n\n        if (\n          previousTile !== undefined &&\n          previousTile.value === currentTile.value\n        ) {\n          const tile = {\n            ...currentTile,\n            position: previousTile.position,\n            mergeWith: previousTile.id,\n          } as TileMeta;\n\n          throttledMergeTile(tile, previousTile);\n          previousTile = undefined;\n          mergeCount += 1;\n          return updateTile(tile);\n        }\n\n        const tile = {\n          ...currentTile,\n          position: indexToPosition(index + size * (maxIndex - i + mergeCount)),\n        } as TileMeta;\n\n        previousTile = tile;\n\n        if (didTileMove(currentTile, tile)) {\n          return updateTile(tile);\n        }\n      });\n    }\n    // wait until the end of all animations.\n    setTimeout(() => dispatch({ type: \"END_MOVE\" }), animationDuration);\n  };\n\n  useEffect(() => {\n    if (isInitialRender.current) {\n      createTile({ position: [0, 1], value: 2 });\n      createTile({ position: [0, 2], value: 2 });\n      isInitialRender.current = false;\n      return;\n    }\n\n    if (!inMotion && hasChanged) {\n      generateRandomTile();\n    }\n  }, [hasChanged, inMotion, createTile, generateRandomTile]);\n\n  const tileList = byIds.map((tileId) => tiles[tileId]);\n  return [tileList, moveLeft, moveRight, moveUp, moveDown] as [\n    TileMeta[],\n    () => void,\n    () => void,\n    () => void,\n    () => void\n  ];\n};\n","import React from \"react\";\n\nimport { size } from \"../../models/Board\";\n\nimport \"./grid.less\";\n\nexport const Grid = () => {\n  const renderGrid = () => {\n    const length = size * size;\n    const cells = [] as JSX.Element[];\n\n    for (let index = 0; index < length; index += 1) {\n      cells.push(<div key={`${index}`} className={`grid-cell`} />);\n    }\n\n    return cells;\n  };\n\n  return <div className=\"grid\">{renderGrid()}</div>;\n};\n","import { useEffect, useRef } from \"react\";\n\n/**\n * `usePrevProps` allows to store previous value of the tracked props.\n *\n * @link https://blog.logrocket.com/how-to-get-previous-props-state-with-react-hooks/\n * @param {K} value\n * @returns {K | undefined}\n */\nexport const usePrevProps = <K = any>(value: K) => {\n  const ref = useRef<K>();\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n};\n","import React, { useEffect, useState } from \"react\";\nimport invariant from \"tiny-invariant\";\nimport { usePrevProps } from \"../../hooks/usePrevProps\";\nimport { useTileContainer } from \"../../hooks/useTileContainer\";\nimport { size } from \"../../models/Board\";\nimport \"./tile.less\";\n\ntype Props = {\n  value: number;\n  position: [number, number];\n  zIndex: number;\n};\n\nexport const Tile = ({ value, position, zIndex }: Props) => {\n  const withinBoardBoundaries = position[0] < size && position[1] < size;\n  invariant(withinBoardBoundaries, \"Tile out of bound\");\n\n  const [scale, setScale] = useState(1);\n\n  const [boardLength] = useTileContainer();\n  const prevValue = usePrevProps<number>(value);\n  const prevCoords = usePrevProps<[number, number]>(position);\n\n  const isNew = prevCoords === undefined;\n  const hasChanged = prevValue !== value;\n  const shallAnimate = isNew || hasChanged;\n\n  useEffect(() => {\n    if (shallAnimate) {\n      setScale(1.1);\n      setTimeout(() => setScale(1), 100);\n    }\n  }, [shallAnimate, scale]);\n\n  const positionToPixels = (position: number) => {\n    return (position / size) * (boardLength as number);\n  };\n\n  const style = {\n    top: positionToPixels(position[1]),\n    left: positionToPixels(position[0]),\n    transform: `scale(${scale})`,\n    zIndex,\n  };\n\n  return (\n    <div className={`tile tile-${value}`} style={style}>\n      {value}\n    </div>\n  );\n};\n","import { useContext } from \"react\";\nimport { TileContainerContext } from \"../context/TileContainer\";\n\n/**\n * Returns the data of the Tile Container.\n *\n * @returns {number}\n */\nexport const useTileContainer = () => {\n  const { length } = useContext(TileContainerContext);\n\n  return [length] as [number];\n};\n","import React, { useEffect, useRef, useState } from \"react\";\nimport { useThrottledCallback } from \"use-debounce\";\nimport { TileContainer } from \"../../context/TileContainer\";\nimport { useGame } from \"../../hooks/useGame\";\nimport { animationDuration } from \"../../models/Board\";\nimport { Grid } from \"../Grid\";\nimport { Tile } from \"../Tile\";\nimport \"./board.less\";\n\nexport const Board = () => {\n  const tileManagerRef = useRef<HTMLDivElement>(null);\n  const [length, setLength] = useState(0);\n  const [tiles, moveLeft, moveRight, moveUp, moveDown] = useGame();\n\n  const handleKeyDown = (e: KeyboardEvent) => {\n    switch (e.code) {\n      case \"ArrowLeft\":\n        moveLeft();\n        break;\n      case \"ArrowRight\":\n        moveRight();\n        break;\n      case \"ArrowUp\":\n        moveUp();\n        break;\n      case \"ArrowDown\":\n        moveDown();\n        break;\n    }\n  };\n  // protects the reducer from being flooded with events.\n  const throttledHandleKeyDown = useThrottledCallback(\n    handleKeyDown,\n    animationDuration,\n    { leading: true, trailing: false }\n  );\n\n  useEffect(() => {\n    if (tileManagerRef.current !== null) {\n      setLength((tileManagerRef.current as HTMLDivElement).offsetWidth);\n    }\n  }, []);\n\n  useEffect(() => {\n    window.addEventListener(\"keydown\", throttledHandleKeyDown);\n\n    return () => {\n      window.removeEventListener(\"keydown\", throttledHandleKeyDown);\n    };\n  }, [throttledHandleKeyDown]);\n\n  const renderTiles = () => {\n    if (length === 0) {\n      return null;\n    }\n\n    const tileList = tiles.map(({ id, ...restProps }) => (\n      <Tile key={`tile-${id}`} {...restProps} zIndex={id} />\n    ));\n\n    return <>{tileList}</>;\n  };\n\n  return (\n    <div className=\"board\">\n      <TileContainer length={length}>\n        <div className=\"tile-container\" ref={tileManagerRef}>\n          {renderTiles()}\n        </div>\n      </TileContainer>\n      <Grid />\n    </div>\n  );\n};\n","import React from \"react\";\nimport \"./button.less\";\n\ntype Props = {\n  children: any;\n  onClick?: () => void;\n};\n\nexport const Button = ({ children, onClick }: Props) => {\n  return (\n    <button className=\"button\" onClick={onClick}>\n      {children}\n    </button>\n  );\n};\n","import React, { useState } from \"react\";\nimport { Board } from \"./components/Board\";\nimport { Button } from \"./components/Button\";\nimport \"./App.less\";\n\n/* eslint-disable react/jsx-no-target-blank */\nexport const App = () => {\n  const [date, setDate] = useState<Date>(new Date());\n\n  const handleRestart = () => {\n    setDate(new Date());\n  };\n\n  return (\n    <div className=\"App\">\n      <div className=\"header\">\n        <div>\n          <h1>Play 2048</h1>\n        </div>\n        <div>\n          <Button onClick={handleRestart}>Restart</Button>\n        </div>\n      </div>\n      <Board key={date.toISOString()} />\n      <div>\n        <p>\n          <b>Wondering how was that built?</b> You can find a video tutorial and\n          code here:\n        </p>\n        <ul>\n          <li>\n            <a\n              href=\"https://www.youtube.com/channel/UCJV16_5c4A0amyBZSI4yP6A\"\n              target=\"_blank\"\n            >\n              Tutorial (YouTube)\n            </a>\n          </li>\n          <li>\n            <a\n              href=\"https://github.com/mateuszsokola/2048-in-react/\"\n              target=\"_blank\"\n            >\n              Source code (Github)\n            </a>\n          </li>\n          <li>\n            <a\n              href=\"https://mateuszsokola.github.io/2048-animation-examples/\"\n              target=\"_blank\"\n            >\n              Animation Examples (Github Pages)\n            </a>\n          </li>\n        </ul>\n        <p>\n          This game (2048) was built using <b>React</b> and <b>TypeScript</b>.\n          The unique part of this example is animations. The animations in React\n          aren't that straightforward, so I hope you can learn something new\n          from it.\n        </p>\n      </div>\n      <div className=\"footer\">\n        Made with ❤️ by{\" \"}\n        <a\n          href=\"https://www.youtube.com/channel/UCJV16_5c4A0amyBZSI4yP6A\"\n          target=\"_blank\"\n        >\n          Matt Sokola\n        </a>\n      </div>\n    </div>\n  );\n};\n/* eslint-enable react/jsx-no-target-blank */\n","import { ReportHandler } from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { App } from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}